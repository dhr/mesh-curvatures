<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Mesh Curvatures</title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style type="text/css">html,
body {
  margin: 0px;
  width: 100%;
  height: 100%;
  overflow: scroll;
  font-family: 'Lucida Grande', sans-serif;
  background-color: #777;
}
canvas {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
}
#instructions {
  position: fixed;
  bottom: 0;
  width: 100%;
  margin: 0;
  padding: 20px;
  background-color: #333;
  color: #aaa;
}
#instructions li {
  display: inline-block;
}
#instructions li + li {
  margin-left: 40px;
}

    </style>
  </head>
  <body>
    <ul id="instructions">
      <li>R - Reset object rotation</li>
      <li>Shift+R - Reset light position</li>
    </ul>
    <script src="three.min.js"></script>
    <script src="dat.gui.min.js"></script>
    <script src="TrackballControls.js"></script>
    <script id="vertShader" type="x-shader/x-vertex">
      attribute vec3 pdir;
      attribute vec2 curvs;
      attribute vec4 dcurvs;
      
      varying vec3 transformedNormal;
      varying float k;
      varying float aniso;
      varying float dkmag;
      
      void main()
      {
        transformedNormal = normalMatrix*normal;
        float k1 = curvs.x, k2 = curvs.y,
              f = dcurvs.x, g = dcurvs.y, h = dcurvs.z, i = dcurvs.w;
        k = k1*k2;
        aniso = 1.0 - abs(k2/k1);
        dkmag = max(max(abs(f), abs(g)), max(abs(h), abs(i)));
        // dkmag = log(abs(k1*k1*(h*h - g*i) + k2*k2*(g*g - f*h)) + 1.0);
        gl_Position = projectionMatrix*modelViewMatrix*vec4(position, 1.0);
      }
      
    </script>
    <script id="fragShader" type="x-shader/x-fragment">
      uniform vec3 directionalLightDirection[MAX_DIR_LIGHTS];
      
      uniform mat3 normalMatrix;
      uniform float lightingAmt;
      uniform bool sphericalHarmonicsLighting;
      uniform int intensityLevels;
      uniform float maxK;
      uniform float maxAniso;
      uniform float maxDCurv;
      uniform float curvSat;
      uniform float anisoSat;
      uniform float dcurvSat;
      
      varying vec3 transformedNormal;
      varying float k;
      varying float aniso;
      varying float dkmag;
      
      void main()
      {
        float nDotV = 1.0;
        for (int i = 0; i < MAX_DIR_LIGHTS; i++) {
          vec3 lightVector = normalize(directionalLightDirection[i]);
          vec3 normal = normalize(transformedNormal);
          nDotV = dot(normal, lightVector);
          if (sphericalHarmonicsLighting) {
            mat4 L = mat4(-0.0230,  0.0102, -0.0043,  0.0043,
                           0.0102, -0.0145, -0.0069,  0.0069,
            -0.0043, -0.0069,  0.0259,  0.0295,
                           0.0043,  0.0069,  0.0295,  0.0738);
                           
            vec3 axis = cross(vec3(0.0, 0.0, 1.0), lightVector);
            float cosTheta = lightVector.z;
            float sinTheta = -length(axis);
            axis = normalize(axis);
            vec3 nrot = normal*cosTheta + cross(axis, normal)*sinTheta +
                        axis*dot(axis, normal)*(1.0 - cosTheta);
            vec4 naug = vec4(nrot, 1.0);
            nDotV = dot(naug, L*naug)/0.1585;
          }
          else
            nDotV = (nDotV + 1.0)/2.0;
        }
        
        vec3 color = vec3(1.0 - max(max(curvSat, dcurvSat), anisoSat)/2.0);
        color.r += curvSat*k/maxK/2.0;
        color.g += dcurvSat*dkmag/maxDCurv/2.0;
        color.b += anisoSat*aniso/maxAniso/2.0;
        
        float shading = 1.0 - lightingAmt*(1.0 - nDotV);
        float numLevels = float(intensityLevels);
        shading = floor(shading*numLevels)/numLevels;
        gl_FragColor = vec4(shading*color, 1.0);
      }
      
    </script>
    <script>(function() {
  var animate, arrowLen, aspect, camera, controls, ctrlFolder, findClosestVertexIndex, getAttributeVec, gui, infoFolder, k, light, loadMesh, loader, material, mesh, meshInfo, meshes, mu, normalArrow, pdir1Arrow, pdir2Arrow, raycaster, render, renderer, scene, showArrows, updateLightPosition, vecConstructors, zeroVec;

  scene = new THREE.Scene();

  aspect = window.innerWidth / window.innerHeight;

  camera = new THREE.PerspectiveCamera(20.5, aspect, 0.1, 1000);

  camera.position.z = 7;

  renderer = new THREE.WebGLRenderer({
    alpha: true
  });

  renderer.setSize(window.innerWidth, window.innerHeight);

  document.body.appendChild(renderer.domElement);

  render = function() {
    return renderer.render(scene, camera);
  };

  controls = new THREE.TrackballControls(camera, renderer.domElement);

  controls.dampingFactor = 0.01;

  controls.addEventListener('change', render);

  material = new THREE.ShaderMaterial({
    uniforms: THREE.UniformsUtils.merge([
      THREE.UniformsLib['lights'], {
        lightingAmt: {
          type: 'f',
          value: 1
        },
        sphericalHarmonicsLighting: {
          type: 'i',
          value: true
        },
        intensityLevels: {
          type: 'i',
          value: 256
        },
        maxK: {
          type: 'f',
          value: 0
        },
        maxAniso: {
          type: 'f',
          value: 0
        },
        maxDCurv: {
          type: 'f',
          value: 0
        },
        curvSat: {
          type: 'f',
          value: 1
        },
        anisoSat: {
          type: 'f',
          value: 0.5
        },
        dcurvSat: {
          type: 'f',
          value: 1
        }
      }
    ]),
    lights: true,
    attributes: {
      pdir: {
        type: 'v3'
      },
      curvs: {
        type: 'v2'
      },
      dcurvs: {
        type: 'v4'
      }
    },
    vertexShader: document.getElementById('vertShader').textContent,
    fragmentShader: document.getElementById('fragShader').textContent
  });

  mesh = new THREE.Mesh(new THREE.IcosahedronGeometry(0.2), new THREE.MeshBasicMaterial({
    wireframe: true
  }));

  scene.add(mesh);

  light = new THREE.DirectionalLight(0xffffff, 0.5);

  light.theta = 0;

  light.phi = 0;

  updateLightPosition = function() {
    var p, t, x, y, z;
    t = light.theta * Math.PI / 180;
    p = light.phi * Math.PI / 180;
    x = Math.sin(t) * Math.cos(p);
    y = Math.sin(p);
    z = Math.cos(t) * Math.cos(p);
    return light.position.set(x, y, z);
  };

  scene.add(light);

  meshes = ['blob01', 'blob06', 'blob07', 'lump000', 'lump001', 'lump002', 'sphere', 'ellipsoid', 'pancake'];

  mesh.name = meshes[0];

  mu = material.uniforms;

  gui = new dat.GUI();

  ctrlFolder = gui.addFolder('Controls');

  ctrlFolder.open();

  ctrlFolder.add(mesh, 'name', meshes).name('Mesh').onChange(function() {
    return loadMesh();
  });

  ctrlFolder.add(mu.lightingAmt, 'value', 0, 1).name('Lighting');

  ctrlFolder.add(mu.sphericalHarmonicsLighting, 'value').name('SH Lighting');

  ctrlFolder.add(mu.intensityLevels, 'value', 10, 256).name('Levels');

  ctrlFolder.add(light, 'theta', -180, 180).step(1).name('Light 𝜃').listen();

  ctrlFolder.add(light, 'phi', -90, 90).step(1).name('Light 𝜑').listen();

  ctrlFolder.add(mu.curvSat, 'value', 0, 1).name('Curvature');

  ctrlFolder.add(mu.anisoSat, 'value', 0, 1).name('Anisotropy');

  ctrlFolder.add(mu.dcurvSat, 'value', 0, 1).name('Third Order');

  meshInfo = {
    k1: '',
    k2: '',
    f: '',
    g: '',
    h: '',
    i: '',
    gauss: '',
    mean: '',
    aniso: ''
  };

  infoFolder = gui.addFolder('Mesh Info');

  infoFolder.open();

  for (k in meshInfo) {
    infoFolder.add(meshInfo, k).listen();
  }

  loader = new THREE.BufferGeometryLoader();

  loadMesh = function() {
    return loader.load("meshes/" + mesh.name + ".json", function(geometry) {
      var curvs, dcurvs, f, g, h, i, k1, k2, maxAniso, maxDCurv, maxK, _i, _j, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;
      curvs = geometry.attributes.curvs;
      maxK = -1 / 0;
      maxAniso = -1 / 0;
      for (i = _i = 0, _ref = curvs.length, _ref1 = curvs.itemSize; _ref1 > 0 ? _i < _ref : _i > _ref; i = _i += _ref1) {
        _ref2 = curvs.array.subarray(i, i + 2), k1 = _ref2[0], k2 = _ref2[1];
        maxK = Math.max(maxK, Math.abs(k1 * k2));
        maxAniso = Math.max(maxAniso, 1 - Math.abs(k2 / k1));
      }
      material.uniforms.maxK.value = maxK;
      material.uniforms.maxAniso.value = maxAniso;
      dcurvs = geometry.attributes.dcurvs;
      maxDCurv = -1 / 0;
      for (i = _j = 0, _ref3 = dcurvs.length, _ref4 = dcurvs.itemSize; _ref4 > 0 ? _j < _ref3 : _j > _ref3; i = _j += _ref4) {
        _ref5 = curvs.array.subarray(i / 4, i / 4 + 2), k1 = _ref5[0], k2 = _ref5[1];
        _ref6 = dcurvs.array.subarray(i, i + 4), f = _ref6[0], g = _ref6[1], h = _ref6[2], i = _ref6[3];
        maxDCurv = Math.max(maxDCurv, f, g, h, i, -f, -g, -h, -i);
      }
      material.uniforms.maxDCurv.value = maxDCurv;
      scene.remove(mesh);
      mesh.geometry = geometry;
      mesh.material = material;
      scene.add(mesh);
      controls.reset();
      return render();
    });
  };

  animate = function() {
    window.requestAnimationFrame(animate);
    updateLightPosition();
    controls.update();
    return render();
  };

  loadMesh();

  animate();

  vecConstructors = [0, 0, THREE.Vector2, THREE.Vector3, THREE.Vector4];

  getAttributeVec = function(geometry, attrName, index) {
    var attr, end, start, vec, _ref;
    attr = geometry.getAttribute(attrName);
    vec = new vecConstructors[attr.itemSize]();
    _ref = [attr.itemSize * index, attr.itemSize * (index + 1)], start = _ref[0], end = _ref[1];
    return vec.fromArray(attr.array.subarray(start, end));
  };

  findClosestVertexIndex = function(g, f, p) {
    var dista, distb, distc, index;
    dista = getAttributeVec(g, 'position', f.a).distanceToSquared(p);
    distb = getAttributeVec(g, 'position', f.b).distanceToSquared(p);
    distc = getAttributeVec(g, 'position', f.c).distanceToSquared(p);
    index = f.a;
    if (distb < dista) {
      index = f.b;
    }
    if (distc < dista && distc < distb) {
      index = f.c;
    }
    return index;
  };

  zeroVec = new THREE.Vector3();

  arrowLen = 0.1;

  pdir1Arrow = new THREE.ArrowHelper(zeroVec, zeroVec, arrowLen, 0xff0000);

  pdir2Arrow = new THREE.ArrowHelper(zeroVec, zeroVec, arrowLen, 0x00ff00);

  normalArrow = new THREE.ArrowHelper(zeroVec, zeroVec, arrowLen, 0x0000ff);

  pdir1Arrow.setLength(arrowLen, 0.2 * arrowLen, 0.2 * arrowLen);

  pdir2Arrow.setLength(arrowLen, 0.2 * arrowLen, 0.2 * arrowLen);

  normalArrow.setLength(arrowLen, 0.2 * arrowLen, 0.2 * arrowLen);

  pdir1Arrow.line.material.linewidth = 3;

  pdir2Arrow.line.material.linewidth = 3;

  normalArrow.line.material.linewidth = 3;

  showArrows = function(tf) {
    pdir1Arrow.visible = tf;
    pdir2Arrow.visible = tf;
    return normalArrow.visible = tf;
  };

  showArrows(false);

  scene.add(pdir1Arrow);

  scene.add(pdir2Arrow);

  scene.add(normalArrow);

  raycaster = new THREE.Raycaster();

  window.addEventListener('mousemove', function(event) {
    var arrowPos, c, canvas, dcurvs, dir, face, index, intxns, k1, k2, normal, pdir1, pdir2, point, tmp, vertex, x, y, _ref, _ref1, _ref2, _ref3, _ref4;
    canvas = renderer.domElement;
    x = 2 * (event.pageX - canvas.offsetLeft) / canvas.offsetWidth - 1;
    y = -2 * (event.pageY - canvas.offsetTop) / canvas.offsetHeight + 1;
    dir = new THREE.Vector3(x, y, 1).unproject(camera);
    dir.sub(camera.position).normalize();
    raycaster.set(camera.position, dir);
    intxns = raycaster.intersectObject(mesh);
    if (intxns.length > 0) {
      _ref = [intxns[0].face, intxns[0].point], face = _ref[0], point = _ref[1];
      index = findClosestVertexIndex(mesh.geometry, face, point);
      _ref1 = getAttributeVec(mesh.geometry, 'curvs', index).toArray(), k1 = _ref1[0], k2 = _ref1[1];
      dcurvs = getAttributeVec(mesh.geometry, 'dcurvs', index).toArray();
      c = meshInfo;
      _ref2 = [k1, k2].map(function(n) {
        return n.toFixed(5);
      }), c.k1 = _ref2[0], c.k2 = _ref2[1];
      tmp = [k1 * k2, (k1 + k2) / 2, 1 - Math.abs(k2 / k1)];
      _ref3 = tmp.map(function(n) {
        return n.toFixed(5);
      }), c.gauss = _ref3[0], c.mean = _ref3[1], c.aniso = _ref3[2];
      _ref4 = dcurvs.map(function(n) {
        return n.toFixed(5);
      }), c.f = _ref4[0], c.g = _ref4[1], c.h = _ref4[2], c.i = _ref4[3];
      pdir1 = getAttributeVec(mesh.geometry, 'pdir', index);
      normal = getAttributeVec(mesh.geometry, 'normal', index);
      pdir2 = normal.clone().cross(pdir1);
      vertex = getAttributeVec(mesh.geometry, 'position', index);
      arrowPos = normal.clone().multiplyScalar(0.001).add(vertex);
      pdir1Arrow.position.copy(arrowPos);
      pdir2Arrow.position.copy(arrowPos);
      normalArrow.position.copy(arrowPos);
      pdir1Arrow.setDirection(pdir1);
      normalArrow.setDirection(normal);
      pdir2Arrow.setDirection(pdir2);
      return showArrows(true);
    } else {
      for (k in meshInfo) {
        meshInfo[k] = '';
      }
      return showArrows(false);
    }
  });

  window.addEventListener('resize', function() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    return controls.handleResize();
  });

  window.addEventListener('keyup', function(event) {
    if (event.keyCode === 82) {
      if (!event.shiftKey) {
        return controls.reset();
      } else {
        light.theta = 0;
        return light.phi = 0;
      }
    }
  });

}).call(this);

    </script>
  </body>
</html>