<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Mesh Curvatures</title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style type="text/css">html,
body {
  margin: 0px;
  width: 100%;
  height: 100%;
  overflow: scroll;
  font-family: 'Lucida Grande', sans-serif;
  background-color: #777;
}
canvas {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
}
#instructions {
  position: fixed;
  bottom: 0;
  width: 100%;
  margin: 0;
  padding: 20px;
  background-color: #333;
  color: #aaa;
}
#instructions li {
  display: inline-block;
}
#instructions li + li {
  margin-left: 40px;
}

    </style>
  </head>
  <body>
    <ul id="instructions">
      <li>R - Reset light position and object rotation</li>
      <li>Shift+R - Reset only light position</li>
    </ul>
    <script src="three.min.js"></script>
    <script src="dat.gui.min.js"></script>
    <script src="TrackballControls.js"></script>
    <script src="OrbitControls.js"></script>
    <script id="vertShader" type="x-shader/x-vertex">
      attribute vec3 pdir;
      attribute vec2 curvs;
      attribute vec4 dcurvs;
      
      varying vec3 transformedNormal;
      varying float k;
      varying float dkmag;
      
      void main()
      {
        transformedNormal = normalMatrix*normal;
        k = curvs.x*curvs.y;
        vec4 abscurvs = abs(dcurvs);
        dkmag = max(max(abscurvs.x, abscurvs.y), max(abscurvs.z, abscurvs.w));
        gl_Position = projectionMatrix*modelViewMatrix*vec4(position, 1.0);
      }
      
    </script>
    <script id="fragShader" type="x-shader/x-fragment">
      uniform vec3 directionalLightDirection[MAX_DIR_LIGHTS];
      
      uniform float maxK;
      uniform float curvSat;
      uniform float maxDCurv;
      uniform float dcurvSat;
      uniform float dcurvBoost;
      uniform float lightingAmt;
      uniform bool hemisphericLighting;
      
      varying vec3 transformedNormal;
      varying float k;
      varying float dkmag;
      
      void main()
      {
        float nDotV = 1.0;
        for (int i = 0; i < MAX_DIR_LIGHTS; i++) {
          vec3 lightVector = normalize(directionalLightDirection[i]);
          vec3 normal = normalize(transformedNormal);
          nDotV = dot(normal, lightVector);
          if (hemisphericLighting)
            nDotV = (nDotV + 1.0)/2.0;
          else
            nDotV = max(nDotV, 0.0);
        }
        float knorm = curvSat*k/maxK/2.0;
        float dknorm = pow(dkmag/maxDCurv, 1.0 - dcurvBoost*0.9)*dcurvSat;
        
        float shading = 1.0 - lightingAmt*(1.0 - nDotV);
        float baseVal = 1.0 - max(curvSat, dcurvSat)/2.0;
        vec3 color = vec3(baseVal + knorm, baseVal + dknorm, baseVal - knorm);
        gl_FragColor = vec4(shading*color, 1.0);
      }
      
    </script>
    <script>(function() {
  var animate, arrowLen, aspect, camera, controls, ctrlFolder, curvatures, findClosestVertexIndex, getAttributeVec, gui, infoFolder, k, light, loadMesh, loader, material, mesh, meshes, mu, normalArrow, pdir1Arrow, pdir2Arrow, raycaster, render, renderer, scene, showArrows, updateLightPosition, vecConstructors, zeroVec;

  scene = new THREE.Scene();

  aspect = window.innerWidth / window.innerHeight;

  camera = new THREE.PerspectiveCamera(20.5, aspect, 0.1, 1000);

  camera.position.z = 7;

  renderer = new THREE.WebGLRenderer({
    alpha: true
  });

  renderer.setSize(window.innerWidth, window.innerHeight);

  document.body.appendChild(renderer.domElement);

  render = function() {
    return renderer.render(scene, camera);
  };

  controls = new THREE.TrackballControls(camera, renderer.domElement);

  controls.dampingFactor = 0.01;

  controls.addEventListener('change', render);

  material = new THREE.ShaderMaterial({
    uniforms: THREE.UniformsUtils.merge([
      THREE.UniformsLib['lights'], {
        maxK: {
          type: 'f',
          value: 0
        },
        maxDCurv: {
          type: 'f',
          value: 0
        },
        lightingAmt: {
          type: 'f',
          value: 1
        },
        hemisphericLighting: {
          type: 'i',
          value: true
        },
        curvSat: {
          type: 'f',
          value: 1
        },
        dcurvSat: {
          type: 'f',
          value: 1
        },
        dcurvBoost: {
          type: 'f',
          value: 0
        }
      }
    ]),
    lights: true,
    attributes: {
      pdir: {
        type: 'v3'
      },
      curvs: {
        type: 'v2'
      },
      dcurvs: {
        type: 'v4'
      }
    },
    vertexShader: document.getElementById('vertShader').textContent,
    fragmentShader: document.getElementById('fragShader').textContent
  });

  mesh = new THREE.Mesh(new THREE.IcosahedronGeometry(0.2), new THREE.MeshBasicMaterial({
    wireframe: true
  }));

  scene.add(mesh);

  light = new THREE.DirectionalLight(0xffffff, 0.5);

  light.theta = 0;

  light.phi = 0;

  updateLightPosition = function() {
    var p, t, x, y, z;
    t = light.theta * Math.PI / 180;
    p = light.phi * Math.PI / 180;
    x = Math.sin(t) * Math.cos(p);
    y = Math.sin(p);
    z = Math.cos(t) * Math.cos(p);
    return light.position.set(x, y, z);
  };

  scene.add(light);

  meshes = ['blob01', 'blob06', 'blob07', 'lump000', 'lump001', 'lump002', 'geosphere'];

  mesh.name = meshes[0];

  mu = material.uniforms;

  gui = new dat.GUI();

  ctrlFolder = gui.addFolder('Controls');

  ctrlFolder.open();

  ctrlFolder.add(mesh, 'name', meshes).name('Mesh').onChange(function() {
    return loadMesh();
  });

  ctrlFolder.add(mu.lightingAmt, 'value', 0, 1).name('Lighting');

  ctrlFolder.add(mu.hemisphericLighting, 'value').name('Hemispheric');

  ctrlFolder.add(light, 'theta', -180, 180).step(1).name('Light 𝜃').listen();

  ctrlFolder.add(light, 'phi', -90, 90).step(1).name('Light 𝜑').listen();

  ctrlFolder.add(mu.curvSat, 'value', 0, 1).name('Curvature');

  ctrlFolder.add(mu.dcurvSat, 'value', 0, 1).name('Third Order');

  curvatures = {
    k1: '',
    k2: '',
    f: '',
    g: '',
    h: '',
    i: ''
  };

  infoFolder = gui.addFolder('Mesh Info');

  infoFolder.open();

  for (k in curvatures) {
    infoFolder.add(curvatures, k).listen();
  }

  loader = new THREE.BufferGeometryLoader();

  loadMesh = function() {
    return loader.load("meshes/" + mesh.name + ".json", function(geometry) {
      var curvs, dcurvs, f, g, h, i, k1, k2, maxDCurv, maxK, _i, _j, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
      curvs = geometry.attributes.curvs;
      maxK = -1 / 0;
      for (i = _i = 0, _ref = curvs.length, _ref1 = curvs.itemSize; _ref1 > 0 ? _i < _ref : _i > _ref; i = _i += _ref1) {
        _ref2 = curvs.array.subarray(i, i + 2), k1 = _ref2[0], k2 = _ref2[1];
        maxK = Math.max(maxK, Math.abs(k1 * k2));
      }
      material.uniforms.maxK.value = maxK;
      dcurvs = geometry.attributes.dcurvs;
      maxDCurv = -1 / 0;
      for (i = _j = 0, _ref3 = dcurvs.length, _ref4 = dcurvs.itemSize; _ref4 > 0 ? _j < _ref3 : _j > _ref3; i = _j += _ref4) {
        _ref5 = dcurvs.array.subarray(i, i + 4), f = _ref5[0], g = _ref5[1], h = _ref5[2], i = _ref5[3];
        maxDCurv = Math.max(maxDCurv, f, g, h, i, -f, -g, -h, -i);
      }
      material.uniforms.maxDCurv.value = maxDCurv;
      scene.remove(mesh);
      mesh.geometry = geometry;
      mesh.material = material;
      scene.add(mesh);
      controls.reset();
      return render();
    });
  };

  animate = function() {
    window.requestAnimationFrame(animate);
    updateLightPosition();
    controls.update();
    return render();
  };

  loadMesh();

  animate();

  vecConstructors = [0, 0, THREE.Vector2, THREE.Vector3, THREE.Vector4];

  getAttributeVec = function(geometry, attrName, index) {
    var attr, end, start, vec, _ref;
    attr = geometry.getAttribute(attrName);
    vec = new vecConstructors[attr.itemSize]();
    _ref = [attr.itemSize * index, attr.itemSize * (index + 1)], start = _ref[0], end = _ref[1];
    return vec.fromArray(attr.array.subarray(start, end));
  };

  findClosestVertexIndex = function(g, f, p) {
    var dista, distb, distc, index;
    dista = getAttributeVec(g, 'position', f.a).distanceToSquared(p);
    distb = getAttributeVec(g, 'position', f.b).distanceToSquared(p);
    distc = getAttributeVec(g, 'position', f.c).distanceToSquared(p);
    index = f.a;
    if (distb < dista) {
      index = f.b;
    }
    if (distc < dista && distc < distb) {
      index = f.c;
    }
    return index;
  };

  zeroVec = new THREE.Vector3();

  arrowLen = 0.1;

  pdir1Arrow = new THREE.ArrowHelper(zeroVec, zeroVec, arrowLen, 0xff0000);

  pdir2Arrow = new THREE.ArrowHelper(zeroVec, zeroVec, arrowLen, 0x00ff00);

  normalArrow = new THREE.ArrowHelper(zeroVec, zeroVec, arrowLen, 0x0000ff);

  pdir1Arrow.setLength(arrowLen, 0.2 * arrowLen, 0.2 * arrowLen);

  pdir2Arrow.setLength(arrowLen, 0.2 * arrowLen, 0.2 * arrowLen);

  normalArrow.setLength(arrowLen, 0.2 * arrowLen, 0.2 * arrowLen);

  pdir1Arrow.line.material.linewidth = 3;

  pdir2Arrow.line.material.linewidth = 3;

  normalArrow.line.material.linewidth = 3;

  showArrows = function(tf) {
    pdir1Arrow.visible = tf;
    pdir2Arrow.visible = tf;
    return normalArrow.visible = tf;
  };

  showArrows(false);

  scene.add(pdir1Arrow);

  scene.add(pdir2Arrow);

  scene.add(normalArrow);

  raycaster = new THREE.Raycaster();

  window.addEventListener('mousemove', function(event) {
    var arrowPos, c, canvas, curvs, dcurvs, dir, face, index, intxns, normal, pdir1, pdir2, point, vertex, x, y, _ref, _ref1, _ref2;
    canvas = renderer.domElement;
    x = 2 * (event.pageX - canvas.offsetLeft) / canvas.offsetWidth - 1;
    y = -2 * (event.pageY - canvas.offsetTop) / canvas.offsetHeight + 1;
    dir = new THREE.Vector3(x, y, 1).unproject(camera);
    dir.sub(camera.position).normalize();
    raycaster.set(camera.position, dir);
    intxns = raycaster.intersectObject(mesh);
    if (intxns.length > 0) {
      _ref = [intxns[0].face, intxns[0].point], face = _ref[0], point = _ref[1];
      index = findClosestVertexIndex(mesh.geometry, face, point);
      curvs = getAttributeVec(mesh.geometry, 'curvs', index);
      dcurvs = getAttributeVec(mesh.geometry, 'dcurvs', index);
      c = curvatures;
      _ref1 = curvs.toArray().map(function(n) {
        return n.toFixed(5);
      }), c.k1 = _ref1[0], c.k2 = _ref1[1];
      _ref2 = dcurvs.toArray().map(function(n) {
        return n.toFixed(5);
      }), c.f = _ref2[0], c.g = _ref2[1], c.h = _ref2[2], c.i = _ref2[3];
      pdir1 = getAttributeVec(mesh.geometry, 'pdir', index);
      normal = getAttributeVec(mesh.geometry, 'normal', index);
      pdir2 = normal.clone().cross(pdir1);
      vertex = getAttributeVec(mesh.geometry, 'position', index);
      arrowPos = normal.clone().multiplyScalar(0.001).add(vertex);
      pdir1Arrow.position.copy(arrowPos);
      pdir2Arrow.position.copy(arrowPos);
      normalArrow.position.copy(arrowPos);
      pdir1Arrow.setDirection(pdir1);
      normalArrow.setDirection(normal);
      pdir2Arrow.setDirection(pdir2);
      return showArrows(true);
    } else {
      for (k in curvatures) {
        curvatures[k] = 0;
      }
      return showArrows(false);
    }
  });

  window.addEventListener('resize', function() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    return controls.handleResize();
  });

  window.addEventListener('keyup', function(event) {
    if (event.keyCode === 82) {
      light.theta = 0;
      light.phi = 0;
      if (!event.shiftKey) {
        return controls.reset();
      }
    }
  });

}).call(this);

    </script>
  </body>
</html>