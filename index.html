<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Mesh Curvatures</title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style type="text/css">html,
body {
  margin: 0px;
  width: 100%;
  height: 100%;
  overflow: scroll;
  font-family: Helvetica;
  color: #999;
}
#instructions {
  position: fixed;
  bottom: 0;
  left: 0;
  margin: 20px;
}
#instructions .instr {
  display: inline-block;
}
#instructions .instr + .instr {
  margin-left: 40px;
}
#sidebar {
  position: fixed;
  top: 0;
  right: 0;
  width: 150px;
  margin: 20px;
}
#sidebar div {
  padding: 10px;
  z-index: 10;
  background-color: #444;
}
#sidebar div + div {
  margin-top: 20px;
}
#sidebar #controls label {
  display: inline-block;
  font-size: 9pt;
}
#sidebar #controls select,
#sidebar #controls input {
  display: block;
  width: 100%;
}
#sidebar #controls * + label {
  margin-top: 10px;
}
#sidebar #info table {
  width: 100%;
  border-collapse: collapse;
}
#sidebar #info td:first-child {
  font-weight: bold;
  text-align: center;
  width: 35px;
  background-color: #555;
}
#sidebar #info pre {
  text-align: right;
}

    </style>
  </head>
  <body>
    <div id="instructions">
      <div class="instr">Arrow Keys - Move light (controls spherical coordinates)</div>
      <div class="instr">R - Reset light position and object rotation</div>
      <div class="instr">Shift+R - Reset only light position</div>
    </div>
    <div id="sidebar">
      <div id="controls">
        <label>Mesh</label>
        <select id="meshSelector"></select>
      </div>
      <div id="info">
        <table>
          <tr>
            <td>ùúÖ<sub>1</sub></td>
            <td>
              <pre id="k1val"></pre>
            </td>
          </tr>
          <tr>
            <td>ùúÖ<sub>2</sub></td>
            <td>
              <pre id="k2val"></pre>
            </td>
          </tr>
          <tr>
            <td>f</td>
            <td>
              <pre id="fval"></pre>
            </td>
          </tr>
          <tr>
            <td>g</td>
            <td>
              <pre id="gval"></pre>
            </td>
          </tr>
          <tr>
            <td>h</td>
            <td>
              <pre id="hval"></pre>
            </td>
          </tr>
          <tr>
            <td>i</td>
            <td>
              <pre id="ival"></pre>
            </td>
          </tr>
        </table>
      </div>
    </div>
    <script src="three.min.js"></script>
    <script src="TrackballControls.js"></script>
    <script src="OrbitControls.js"></script>
    <script id="vertShader" type="x-shader/x-vertex">
      attribute vec3 pdir;
      attribute vec2 curvs;
      attribute vec4 dcurvs;
      
      varying vec3 transformedNormal;
      varying float k;
      varying float dkmag;
      
      void main()
      {
        transformedNormal = normalMatrix*normal;
        k = curvs.x*curvs.y;
        vec4 abscurvs = abs(dcurvs);
        dkmag = max(max(abscurvs.x, abscurvs.y), max(abscurvs.z, abscurvs.w));
        gl_Position = projectionMatrix*modelViewMatrix*vec4(position, 1.0);
      }
      
    </script>
    <script id="fragShader" type="x-shader/x-fragment">
      uniform vec3 directionalLightDirection[MAX_DIR_LIGHTS];
      
      uniform float maxK;
      uniform float curvSat;
      uniform float maxDCurv;
      uniform float dcurvSat;
      uniform float dcurvBoost;
      uniform float lightingAmt;
      
      varying vec3 transformedNormal;
      varying float k;
      varying float dkmag;
      
      void main()
      {
        float nDotV = 1.0;
        for (int i = 0; i < MAX_DIR_LIGHTS; i++) {
          vec3 lightVector = normalize(directionalLightDirection[i]);
          vec3 normal = normalize(transformedNormal);
          nDotV = clamp(dot(normal, lightVector), 0.0, 1.0);
        }
        float knorm = curvSat*k/maxK/2.0;
        float dknorm = pow(dkmag/maxDCurv, 1.0 - dcurvBoost*0.9)*dcurvSat/2.0;
        
        float shading = 1.0 - lightingAmt*(1.0 - nDotV);
        vec3 color = shading*vec3(0.5 + knorm, 0.5 + dknorm, 0.5 - knorm);
        gl_FragColor = vec4(color, 1.0);
      }
      
    </script>
    <script>(function() {
  var animate, arrowLen, aspect, camera, clearCurvatureDisplay, controls, findClosestVertexIndex, fval, getAttributeVec, gval, hval, id, ival, k1val, k2val, light, lightAngleInc, lightPhi, lightTheta, loadMesh, loader, material, mesh, meshName, meshSelector, meshes, newLabel, newSlider, normalArrow, option, p, pdir1Arrow, pdir2Arrow, raycaster, render, renderer, scene, setLightPosition, showArrows, vecConstructors, zeroVec, _i, _len, _ref;

  scene = new THREE.Scene();

  aspect = window.innerWidth / window.innerHeight;

  camera = new THREE.PerspectiveCamera(20.5, aspect, 0.1, 1000);

  camera.position.z = 7;

  renderer = new THREE.WebGLRenderer();

  renderer.setSize(window.innerWidth, window.innerHeight);

  document.body.appendChild(renderer.domElement);

  render = function() {
    return renderer.render(scene, camera);
  };

  controls = new THREE.TrackballControls(camera, renderer.domElement);

  controls.dampingFactor = 0.01;

  controls.addEventListener('change', render);

  material = new THREE.ShaderMaterial({
    uniforms: THREE.UniformsUtils.merge([
      THREE.UniformsLib['lights'], {
        maxK: {
          type: 'f',
          value: 0
        },
        maxDCurv: {
          type: 'f',
          value: 0
        },
        lightingAmt: {
          type: 'f',
          label: 'Lighting',
          range: [0, 1],
          value: 0.5
        },
        curvSat: {
          type: 'f',
          label: 'Curvature',
          range: [0, 1],
          value: 1
        },
        dcurvSat: {
          type: 'f',
          label: 'Third Order',
          range: [0, 1],
          value: 1
        },
        dcurvBoost: {
          type: 'f',
          label: 'Third Order Boost',
          range: [0, 1],
          value: 0
        }
      }
    ]),
    lights: true,
    attributes: {
      pdir: {
        type: 'v3'
      },
      curvs: {
        type: 'v2'
      },
      dcurvs: {
        type: 'v4'
      }
    },
    vertexShader: document.getElementById('vertShader').textContent,
    fragmentShader: document.getElementById('fragShader').textContent
  });

  _ref = material.uniforms;
  for (id in _ref) {
    p = _ref[id];
    if ('label' in p) {
      newLabel = document.createElement('label');
      newLabel.setAttribute('for', id);
      newLabel.innerHTML = p.label;
      newSlider = document.createElement('input');
      newSlider.setAttribute('id', id);
      newSlider.setAttribute('type', 'range');
      newSlider.setAttribute('value', p.value);
      newSlider.setAttribute('min', p.range[0]);
      newSlider.setAttribute('max', p.range[1]);
      newSlider.setAttribute('step', 0.01);
      document.getElementById('controls').appendChild(newLabel);
      document.getElementById('controls').appendChild(newSlider);
    }
  }

  meshSelector = document.getElementById('meshSelector');

  meshes = ['blob01', 'blob06', 'blob07', 'lump000', 'lump001', 'lump002'];

  for (_i = 0, _len = meshes.length; _i < _len; _i++) {
    meshName = meshes[_i];
    option = document.createElement('option');
    option.innerHTML = meshName;
    meshSelector.appendChild(option);
  }

  mesh = new THREE.Mesh(new THREE.IcosahedronGeometry(0.2), new THREE.MeshBasicMaterial({
    wireframe: true
  }));

  scene.add(mesh);

  light = new THREE.DirectionalLight(0xffffff, 0.5);

  lightTheta = 0;

  lightPhi = 0;

  lightAngleInc = Math.PI / 2 / 30;

  setLightPosition = function(theta, phi) {
    var x, y, z;
    x = Math.sin(theta) * Math.cos(phi);
    y = Math.sin(phi);
    z = Math.cos(theta) * Math.cos(phi);
    return light.position.set(x, y, z);
  };

  setLightPosition(lightTheta, lightPhi);

  scene.add(light);

  loader = new THREE.BufferGeometryLoader();

  loadMesh = function() {
    return loader.load("meshes/" + meshSelector.value + ".json", function(geometry) {
      var curvs, dcurvs, f, g, h, i, k1, k2, maxDCurv, maxK, _j, _k, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;
      curvs = geometry.attributes.curvs;
      maxK = -1 / 0;
      for (i = _j = 0, _ref1 = curvs.length, _ref2 = curvs.itemSize; _ref2 > 0 ? _j < _ref1 : _j > _ref1; i = _j += _ref2) {
        _ref3 = curvs.array.subarray(i, i + 2), k1 = _ref3[0], k2 = _ref3[1];
        maxK = Math.max(maxK, Math.abs(k1 * k2));
      }
      material.uniforms.maxK.value = maxK;
      dcurvs = geometry.attributes.dcurvs;
      maxDCurv = -1 / 0;
      for (i = _k = 0, _ref4 = dcurvs.length, _ref5 = dcurvs.itemSize; _ref5 > 0 ? _k < _ref4 : _k > _ref4; i = _k += _ref5) {
        _ref6 = dcurvs.array.subarray(i, i + 4), f = _ref6[0], g = _ref6[1], h = _ref6[2], i = _ref6[3];
        maxDCurv = Math.max(maxDCurv, f, g, h, i, -f, -g, -h, -i);
      }
      material.uniforms.maxDCurv.value = maxDCurv;
      scene.remove(mesh);
      mesh.geometry = geometry;
      mesh.material = material;
      scene.add(mesh);
      controls.reset();
      return render();
    });
  };

  animate = function() {
    var _ref1;
    window.requestAnimationFrame(animate);
    _ref1 = material.uniforms;
    for (id in _ref1) {
      p = _ref1[id];
      if ('label' in p) {
        p.value = +document.getElementById(id).value;
      }
    }
    controls.update();
    return render();
  };

  loadMesh();

  animate();

  meshSelector.addEventListener('change', loadMesh);

  vecConstructors = [0, 0, THREE.Vector2, THREE.Vector3, THREE.Vector4];

  getAttributeVec = function(geometry, attrName, index) {
    var attr, end, start, vec, _ref1;
    attr = geometry.getAttribute(attrName);
    vec = new vecConstructors[attr.itemSize]();
    _ref1 = [attr.itemSize * index, attr.itemSize * (index + 1)], start = _ref1[0], end = _ref1[1];
    return vec.fromArray(attr.array.subarray(start, end));
  };

  findClosestVertexIndex = function(g, f, p) {
    var dista, distb, distc, index;
    dista = getAttributeVec(g, 'position', f.a).distanceToSquared(p);
    distb = getAttributeVec(g, 'position', f.b).distanceToSquared(p);
    distc = getAttributeVec(g, 'position', f.c).distanceToSquared(p);
    index = f.a;
    if (distb < dista) {
      index = f.b;
    }
    if (distc < dista && distc < distb) {
      index = f.c;
    }
    return index;
  };

  k1val = document.getElementById('k1val');

  k2val = document.getElementById('k2val');

  fval = document.getElementById('fval');

  gval = document.getElementById('gval');

  hval = document.getElementById('hval');

  ival = document.getElementById('ival');

  clearCurvatureDisplay = function() {
    k1val.innerHTML = ' ';
    k2val.innerHTML = ' ';
    fval.innerHTML = ' ';
    gval.innerHTML = ' ';
    hval.innerHTML = ' ';
    return ival.innerHTML = ' ';
  };

  clearCurvatureDisplay();

  zeroVec = new THREE.Vector3();

  arrowLen = 0.1;

  pdir1Arrow = new THREE.ArrowHelper(zeroVec, zeroVec, arrowLen, 0xff0000);

  pdir2Arrow = new THREE.ArrowHelper(zeroVec, zeroVec, arrowLen, 0x00ff00);

  normalArrow = new THREE.ArrowHelper(zeroVec, zeroVec, arrowLen, 0x0000ff);

  pdir1Arrow.setLength(arrowLen, 0.2 * arrowLen, 0.2 * arrowLen);

  pdir2Arrow.setLength(arrowLen, 0.2 * arrowLen, 0.2 * arrowLen);

  normalArrow.setLength(arrowLen, 0.2 * arrowLen, 0.2 * arrowLen);

  pdir1Arrow.line.material.linewidth = 3;

  pdir2Arrow.line.material.linewidth = 3;

  normalArrow.line.material.linewidth = 3;

  showArrows = function(tf) {
    pdir1Arrow.visible = tf;
    pdir2Arrow.visible = tf;
    return normalArrow.visible = tf;
  };

  showArrows(false);

  scene.add(pdir1Arrow);

  scene.add(pdir2Arrow);

  scene.add(normalArrow);

  raycaster = new THREE.Raycaster();

  window.addEventListener('mousemove', function(event) {
    var arrowPos, curvs, dcurvs, dir, face, index, intxns, normal, pdir1, pdir2, point, vertex, x, y, _ref1, _ref2, _ref3;
    x = 2 * event.clientX / window.innerWidth - 1;
    y = -2 * event.clientY / window.innerHeight + 1;
    dir = new THREE.Vector3(x, y, 1).unproject(camera);
    dir.sub(camera.position).normalize();
    raycaster.set(camera.position, dir);
    intxns = raycaster.intersectObject(mesh);
    if (intxns.length > 0) {
      _ref1 = [intxns[0].face, intxns[0].point], face = _ref1[0], point = _ref1[1];
      index = findClosestVertexIndex(mesh.geometry, face, point);
      curvs = getAttributeVec(mesh.geometry, 'curvs', index);
      _ref2 = curvs.toArray().map(function(n) {
        return n.toFixed(6);
      }), k1val.innerHTML = _ref2[0], k2val.innerHTML = _ref2[1];
      dcurvs = getAttributeVec(mesh.geometry, 'dcurvs', index);
      _ref3 = dcurvs.toArray().map(function(n) {
        return n.toFixed(6);
      }), fval.innerHTML = _ref3[0], gval.innerHTML = _ref3[1], hval.innerHTML = _ref3[2], ival.innerHTML = _ref3[3];
      pdir1 = getAttributeVec(mesh.geometry, 'pdir', index);
      normal = getAttributeVec(mesh.geometry, 'normal', index);
      pdir2 = normal.clone().cross(pdir1);
      vertex = getAttributeVec(mesh.geometry, 'position', index);
      arrowPos = normal.clone().multiplyScalar(0.001).add(vertex);
      pdir1Arrow.position.copy(arrowPos);
      pdir2Arrow.position.copy(arrowPos);
      normalArrow.position.copy(arrowPos);
      pdir1Arrow.setDirection(pdir1);
      normalArrow.setDirection(normal);
      pdir2Arrow.setDirection(pdir2);
      return showArrows(true);
    } else {
      clearCurvatureDisplay();
      return showArrows(false);
    }
  });

  window.addEventListener('resize', function() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    return controls.handleResize();
  });

  window.addEventListener('keydown', function(event) {
    event.preventDefault();
    if (event.keyCode === 39) {
      lightTheta = Math.min(lightTheta + lightAngleInc, Math.PI / 2);
    }
    if (event.keyCode === 37) {
      lightTheta = Math.max(lightTheta - lightAngleInc, -Math.PI / 2);
    }
    if (event.keyCode === 38) {
      lightPhi = Math.min(lightPhi + lightAngleInc, Math.PI / 2);
    }
    if (event.keyCode === 40) {
      lightPhi = Math.max(lightPhi - lightAngleInc, -Math.PI / 2);
    }
    return setLightPosition(lightTheta, lightPhi);
  });

  window.addEventListener('keyup', function(event) {
    if (event.keyCode === 82) {
      lightTheta = 0;
      lightPhi = 0;
      setLightPosition(lightTheta, lightPhi);
      if (!event.shiftKey) {
        return controls.reset();
      }
    }
  });

}).call(this);

    </script>
  </body>
</html>